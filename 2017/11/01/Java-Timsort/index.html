<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|黑体:300,300italic,400,400italic,700,700italic|Microsoft YaHei UI:300,300italic,400,400italic,700,700italic|Arial Black:300,300italic,400,400italic,700,700italic|DejaVu Sans Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="算法,排序," />








  <link rel="shortcut icon" type="image/x-icon" href="/askdog.png?v=5.1.2" />






<meta name="description" content="Timsort简介Timsort是结合了合并排序（merge sort）和插入排序（insertion sort）而得出的排序算法，它在现实中有很好的效率。Tim Peters在2002年设计了该算法并在Python中使用（TimSort 是 Python 中 list.sort 的默认实现）。该算法找到数据中已经排好序的块-分区，每一个分区叫一个run，然后按规则合并这些run。Pyhton自从">
<meta name="keywords" content="算法,排序">
<meta property="og:type" content="article">
<meta property="og:title" content="Timsort算法分析">
<meta property="og:url" content="http://icechen.top/2017/11/01/Java-Timsort/index.html">
<meta property="og:site_name" content="River Blog">
<meta property="og:description" content="Timsort简介Timsort是结合了合并排序（merge sort）和插入排序（insertion sort）而得出的排序算法，它在现实中有很好的效率。Tim Peters在2002年设计了该算法并在Python中使用（TimSort 是 Python 中 list.sort 的默认实现）。该算法找到数据中已经排好序的块-分区，每一个分区叫一个run，然后按规则合并这些run。Pyhton自从">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/Sz4j8uaEeaXpqP7pPFk5Ai34rRb7JB7WQshFObFR.png">
<meta property="og:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/PquHM1PEmayUineexR5E0ISpswmccbyTkII8KxTg.png">
<meta property="og:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/Mx0Q90icYl3PtWFqKiMaILvYuGvaTanJVPYRcEo0.png">
<meta property="og:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/T4gmjp698bTRAPQ9ly38keWyEiFlslbuWvVhJfFO.png">
<meta property="og:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/2aGbjhj1fDGDkkmPoJ8UigkQQwDnq8wN6TmnqceC.png">
<meta property="og:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/TIM%E5%9B%BE%E7%89%8720171101140930.png">
<meta property="og:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/TIM%E5%9B%BE%E7%89%8720171101141114.png">
<meta property="og:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/TIM%E5%9B%BE%E7%89%8720171101141353.png">
<meta property="og:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/1352947294_8034.jpg">
<meta property="og:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/1352947419_3920.jpg">
<meta property="og:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/kGmWwAijwtoxIYCpytEs9HpqeL6yRxCuYINBkv6U.gif">
<meta property="og:updated_time" content="2017-11-02T04:40:54.899Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Timsort算法分析">
<meta name="twitter:description" content="Timsort简介Timsort是结合了合并排序（merge sort）和插入排序（insertion sort）而得出的排序算法，它在现实中有很好的效率。Tim Peters在2002年设计了该算法并在Python中使用（TimSort 是 Python 中 list.sort 的默认实现）。该算法找到数据中已经排好序的块-分区，每一个分区叫一个run，然后按规则合并这些run。Pyhton自从">
<meta name="twitter:image" content="http://7xjzgw.com1.z0.glb.clouddn.com/Sz4j8uaEeaXpqP7pPFk5Ai34rRb7JB7WQshFObFR.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://icechen.top/2017/11/01/Java-Timsort/"/>





  <title>Timsort算法分析 | River Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">River Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">向前看，不要向后看</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://icechen.top/2017/11/01/Java-Timsort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DOGDONG">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xjzgw.com1.z0.glb.clouddn.com/TIM%E5%9B%BE%E7%89%8720170930152824.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="River Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Timsort算法分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T14:37:13+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Timsort简介"><a href="#Timsort简介" class="headerlink" title="Timsort简介"></a>Timsort简介</h1><p>Timsort是结合了合并排序（merge sort）和插入排序（insertion sort）而得出的排序算法，它在现实中有很好的效率。Tim Peters在2002年设计了该算法并在Python中使用（TimSort 是 Python 中 list.sort 的默认实现）。该算法找到数据中已经排好序的块-分区，每一个分区叫一个run，然后按规则合并这些run。Pyhton自从2.3版以来一直采用Timsort算法排序，现在Java SE7和Android也采用Timsort算法对数组排序。</p>
<h1 id="Timsort原理"><a href="#Timsort原理" class="headerlink" title="Timsort原理"></a>Timsort原理</h1><p>Timsort的核心思想是对传统归并排序的最小划分做优化。<br>我们知道归并排序反复调用自身对前一半与后一半的数组进行排序，然后对二者进行合并，最终实际上划分的最小归并集是每个元素，然后逐步迭代合并排序整个数组，所以归并排序对所有情况的复杂度一样恒定为 O(nlogn)。<br>Timsort则是把原数组按照一定规则分成一个一个的块（run）作为最小归并集，再通过优化的合并方法对每个块（run）进行合并，最后一个块（run）便是排序好的数列。</p>
<p>综上述过程，Timsort算法的过程包括：</p>
<ol>
<li>划分一个run，并且入栈</li>
<li>当栈内的run满足一定条件，则合并</li>
<li>重复1，直到待排序数组为空且栈中只剩最后一run，输出run即为排序结果</li>
</ol>
<h2 id="Step1-分区、入栈、合并"><a href="#Step1-分区、入栈、合并" class="headerlink" title="Step1.分区、入栈、合并"></a>Step1.分区、入栈、合并</h2><p>首先，每个run都要求单调递增或者递减，如下图所示：</p>
<p><img src="http://7xjzgw.com1.z0.glb.clouddn.com/Sz4j8uaEeaXpqP7pPFk5Ai34rRb7JB7WQshFObFR.png" alt="run"></p>
<p>当然在实际操作的过程中，我们会设定一个阈值minrun，如果一个run的长度小于minrun，则使用插入排序进行扩充，直到run的长度等于minrun。</p>
<p>然后，对划分的run入栈，当栈顶的run的长度<strong>不满足</strong>下列约束条件中<strong>任意</strong>一个时，</p>
<ol>
<li>runLen[n-2] &gt; runLen[n-1] + runLen[n]</li>
<li>runLen[n-1] &gt; runLen[n]</li>
</ol>
<p>则调用优化的合并函数将两个最短的run合并成一个新的run。（之后会对这两个条件的设置进行解释）</p>
<p>下面以一个实例进行说明。<br>我们设置minrun=4，也就是说run的最小长度不能小于4。每划分出一个run就将其入栈，如下图所示</p>
<p><img src="http://7xjzgw.com1.z0.glb.clouddn.com/PquHM1PEmayUineexR5E0ISpswmccbyTkII8KxTg.png" alt="ex1"></p>
<p>注意，此时栈顶的run是不满足约束条件的，因为此时runLen[0] &lt; runLen<a href="http://7xjzgw.com1.z0.glb.clouddn.com/Sz4j8uaEeaXpqP7pPFk5Ai34rRb7JB7WQshFObFR.png" target="_blank" rel="external">1</a>，所以要对这两个run进行归并，当然这个过程使用的是优化合并函数。</p>
<p>如果遇到有序片段长度小于minrun，则要进行补齐，如下图所示</p>
<p><img src="http://7xjzgw.com1.z0.glb.clouddn.com/Mx0Q90icYl3PtWFqKiMaILvYuGvaTanJVPYRcEo0.png" alt="ex2"></p>
<p>注意，此时栈顶run是满足约束条件的，10 &gt; 5 + 4，5 &gt; 4，因此不需要进行归并。</p>
<p>最后数组元素个数不足minrun了，只能作为一个run了</p>
<p><img src="http://7xjzgw.com1.z0.glb.clouddn.com/T4gmjp698bTRAPQ9ly38keWyEiFlslbuWvVhJfFO.png" alt="ex3"></p>
<p>此时栈顶的run又不满足约束条件了，5 &lt; 4 + 2，所以需要进行归并。后续过程如下图所示</p>
<p><img src="http://7xjzgw.com1.z0.glb.clouddn.com/2aGbjhj1fDGDkkmPoJ8UigkQQwDnq8wN6TmnqceC.png" alt="ex4"></p>
<p>到这里算是排序完成了，这里对之前那个两个约束条件解释说明一下：</p>
<p>首先，我们是可以去掉这两个约束条件的，合并规则变为</p>
<blockquote>
<p>每当有一个新的run入栈就进行一次合并</p>
</blockquote>
<p>这样会出现多次将一个长序列与一个短序列进行合并，导致对长序列进行了多次不必要的检查，效率低下。</p>
<p>举个例子<br>我们有 4个run，A , B , C , D 的长度分别为 100 , 4 , 4 , 4</p>
<p>如果不做长度检查直接合并<br>合并次序为:</p>
<ol>
<li>T = A + B (100+4)</li>
<li>T = T + C (104+4)</li>
<li>T = T + D (108+4)</li>
</ol>
<p>总共步骤合计 sum = 324</p>
<p>如果检查合并<br>合并次序为:</p>
<ol>
<li>T = B + C (4+4)</li>
<li>T = T + D (8+4)</li>
<li>T = A + T (100+12)</li>
</ol>
<p>总共步骤合计 sum = 132</p>
<p>所以很明显，合并之前做长度检查是想尽量使长度均衡的run先合并，从而使整体算法变得高效。</p>
<h2 id="Step2-合并优化"><a href="#Step2-合并优化" class="headerlink" title="Step2.合并优化"></a>Step2.合并优化</h2><p>Step1中只介绍了Timsort算法主体的思路，实际操作上还有非常多的细节处理，这里介绍一下最关键的一个优化，合并优化。</p>
<p><strong>找到待归并区间</strong></p>
<p><img src="http://7xjzgw.com1.z0.glb.clouddn.com/TIM%E5%9B%BE%E7%89%8720171101140930.png" alt="merge1"></p>
<p>从数组A中，找到A[n-1]<b[0] &&="" a[n]="">B[0]，以及A[m]<b[length-1] &&="" a[m+1]="">B[length-1]。<br>此时，待归并区间就是A[n,m]和B。</b[length-1]></b[0]></p>
<p>这样一来较长的run，A就不用遍历左右已经排好序的部分了</p>
<p><strong>准备操作</strong><br>在正式开始归并之前，会做一些准备操作。包括将非待归并区间的数据移动到合适的位置上；准备一个临时数组、初始化一些指针数据等。如下图。</p>
<p><img src="http://7xjzgw.com1.z0.glb.clouddn.com/TIM%E5%9B%BE%E7%89%8720171101141114.png" alt="merge3"></p>
<p><strong>TimSort的优化归并操作</strong><br>TimSort在某些情况（触发条件待考）下，会对上述归并操作做一个优化。主要的优化点在于：不是一次一个元素的移动，而是尝试着一次移动多个元素。<br>下图是按优化后的逻辑，同样的示例数据从准备操作（左上角标记0）到完成排序的归并步骤。注意第一步和第二步每次都移动了两个元素。这里只用了5步就完成了归并；而传统的归并操作需要7步。</p>
<p><img src="http://7xjzgw.com1.z0.glb.clouddn.com/TIM%E5%9B%BE%E7%89%8720171101141353.png" alt="merge4"></p>
<h1 id="Timsort性能分析"><a href="#Timsort性能分析" class="headerlink" title="Timsort性能分析"></a>Timsort性能分析</h1><p>时间复杂度：</p>
<p><img src="http://7xjzgw.com1.z0.glb.clouddn.com/1352947294_8034.jpg" alt="O"></p>
<p>空间复杂度：</p>
<p><img src="http://7xjzgw.com1.z0.glb.clouddn.com/1352947419_3920.jpg" alt="o"></p>
<p>相对而言，Timsort是稳定的算法，当待排序的数组中已经有排序好的数，它的时间复杂度会小于n logn。与其他合并排序一样，Timesrot是稳定的排序算法，最坏时间复杂度是O（n log n）。在最坏情况下，Timsort算法需要的临时空间是n/2，在最好情况下，它只需要一个很小的临时存储空间</p>
<p>下面给一个gif可以直观了解排序过程，其实基本跟传统归并排序一样</p>
<p><img src="http://7xjzgw.com1.z0.glb.clouddn.com/kGmWwAijwtoxIYCpytEs9HpqeL6yRxCuYINBkv6U.gif" alt="此处输入图片的描述"></p>
<h1 id="存在的BUG"><a href="#存在的BUG" class="headerlink" title="存在的BUG"></a>存在的BUG</h1><p>了解了Timsort算法的过程和原理，好像没有什么逻辑上的问题，那么这个Bug到底出在哪呢？</p>
<p>这个Bug恰恰出现在那个约束条件上，因为Timsort算法设置这个约束条件的是为了保证归并排序时两个子序列长度是均衡的，隐含的一层意思是栈内所有run都应该满足该约束条件（即使不在栈顶），即对2 &lt;= i &lt;= StackSize-1，也必须满足：</p>
<ol>
<li>runLen[n-2] &gt; runLen[n-1] + runLen[n]</li>
<li>runLen[n-1] &gt; runLen[n]</li>
</ol>
<p>在大多数情况下，仅检查栈顶的3个run是否满足这个约束条件是可以保证整个栈内所有run均满足该约束条件。但是在一些特殊的情况下就不行了，如下面这个栈（右侧为栈顶）</p>
<blockquote>
<p>120, 80, 25, 20, 30</p>
</blockquote>
<p>因为25 &lt; 20 + 30，25 &lt; 30，所以将25和20两个run进行合并，此时栈内的情况变为</p>
<blockquote>
<p>120, 80, 45, 30</p>
</blockquote>
<p>由于80 &gt; 45 + 30，45 &gt; 30，满足约束条件，此时归并就终止了。但是注意栈里的其他run，120 &lt; 80 + 45，这是不满足约束条件的，而由于我们只判断了栈顶的run，因此在这里就留下了“隐患”。</p>
<p>还有许多细节，这里不做深入探讨，若有兴趣可自行查阅相关文档。</p>
<h1 id="Java源码-注释"><a href="#Java源码-注释" class="headerlink" title="Java源码+注释"></a>Java源码+注释</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div><div class="line">793</div><div class="line">794</div><div class="line">795</div><div class="line">796</div><div class="line">797</div><div class="line">798</div><div class="line">799</div><div class="line">800</div><div class="line">801</div><div class="line">802</div><div class="line">803</div><div class="line">804</div><div class="line">805</div><div class="line">806</div><div class="line">807</div><div class="line">808</div><div class="line">809</div><div class="line">810</div><div class="line">811</div><div class="line">812</div><div class="line">813</div><div class="line">814</div><div class="line">815</div><div class="line">816</div><div class="line">817</div><div class="line">818</div><div class="line">819</div><div class="line">820</div><div class="line">821</div><div class="line">822</div><div class="line">823</div><div class="line">824</div><div class="line">825</div><div class="line">826</div><div class="line">827</div><div class="line">828</div><div class="line">829</div><div class="line">830</div><div class="line">831</div><div class="line">832</div><div class="line">833</div><div class="line">834</div><div class="line">835</div><div class="line">836</div><div class="line">837</div><div class="line">838</div><div class="line">839</div><div class="line">840</div><div class="line">841</div><div class="line">842</div><div class="line">843</div><div class="line">844</div><div class="line">845</div><div class="line">846</div><div class="line">847</div><div class="line">848</div><div class="line">849</div><div class="line">850</div><div class="line">851</div><div class="line">852</div><div class="line">853</div><div class="line">854</div><div class="line">855</div><div class="line">856</div><div class="line">857</div><div class="line">858</div><div class="line">859</div><div class="line">860</div><div class="line">861</div><div class="line">862</div><div class="line">863</div><div class="line">864</div><div class="line">865</div><div class="line">866</div><div class="line">867</div><div class="line">868</div><div class="line">869</div><div class="line">870</div><div class="line">871</div><div class="line">872</div><div class="line">873</div><div class="line">874</div><div class="line">875</div><div class="line">876</div><div class="line">877</div><div class="line">878</div><div class="line">879</div><div class="line">880</div><div class="line">881</div><div class="line">882</div><div class="line">883</div><div class="line">884</div><div class="line">885</div><div class="line">886</div><div class="line">887</div><div class="line">888</div><div class="line">889</div><div class="line">890</div><div class="line">891</div><div class="line">892</div><div class="line">893</div><div class="line">894</div><div class="line">895</div><div class="line">896</div><div class="line">897</div><div class="line">898</div><div class="line">899</div><div class="line">900</div><div class="line">901</div><div class="line">902</div><div class="line">903</div><div class="line">904</div><div class="line">905</div><div class="line">906</div><div class="line">907</div><div class="line">908</div><div class="line">909</div><div class="line">910</div><div class="line">911</div><div class="line">912</div><div class="line">913</div><div class="line">914</div><div class="line">915</div><div class="line">916</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by yxf on 16-5-30.</span></div><div class="line"><span class="comment"> * 这里对TimSort算法在java中的实现做了注释，部分实现逻辑相似的注释没有处理，直接是原来的注释。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 参与序列合并的最短长度。比这个更短的序列将会通过二叉插入排序加长。如果整个数组都比这个短，那就不会经过归并排序。</span></div><div class="line"><span class="comment">   * &lt;p/&gt;</span></div><div class="line"><span class="comment">   * 这个常量的值必须2的幂。Tim Perter</span></div><div class="line"><span class="comment">   * 在C语言中的实现版本使用了64，但是根据经验这里的版本使用32更合适。在最坏的情况下，使用了非2的幂赋值，就必须要重写</span></div><div class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> # minRunLength&#125;这个方法。 如果减小了这个值，就需要在构造方法中减小stackLen的值，不然将面临数组越界的风险。</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_MERGE = <span class="number">32</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 将要被排序的数组</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> T[] a;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 这次排序的比较器</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> T&gt; c;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 判断数据顺序连续性的阈值 后面结合代码看，会容易理解一点</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_GALLOP = <span class="number">7</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minGallop = MIN_GALLOP;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 归并排序中临时数组的最大长度，数组的长度也可以根据需求增长。</span></div><div class="line"><span class="comment">   * 与C语言中的实现方式不同，对于相对较小的数组，我们不用这么大的临时数组。这点改变对性能有显著的影响</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_TMP_STORAGE_LENGTH = <span class="number">256</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 临时数组，根据泛型的内容可知，实际的存储要用Object[],不能用T[]</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> T[] tmp;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 栈中待归并的run的数量。一个run i的范围从runBase[i]开始，一直延续到runLen[i]。</span></div><div class="line"><span class="comment">   * 下面这个根据前一个run的结尾总是下一个run的开头。 所以下面的等式总是成立: runBase[i] + runLen[i] ==</span></div><div class="line"><span class="comment">   * runBase[i+1];</span></div><div class="line"><span class="comment">   **/</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> stackSize = <span class="number">0</span>; <span class="comment">// 栈中run的数量</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] runBase;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] runLen;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 这个构造方法是私有的所以只能在类内部创建。 创建这个实例是为了保存一次排序过程中的状态变量。</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">TimSort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = a;</div><div class="line">    <span class="keyword">this</span>.c = c;</div><div class="line"></div><div class="line">    <span class="comment">// 这里是分配临时数组的空间。SuppressWainings是为了消除泛型数组转型的警告</span></div><div class="line">    <span class="comment">// 临时数组的长度写的很精炼，不明白的自己熟悉一下java位操作。</span></div><div class="line">    <span class="comment">// 结果就是 数组长度的一半或者是INITIAL_TMP_STORAGE_LENGTH</span></div><div class="line">    <span class="keyword">int</span> len = a.length;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;</div><div class="line">        <span class="string">"unchecked"</span>, <span class="string">"UnnecessaryLocalVariable"</span> &#125;)</div><div class="line">    T[] newArray = (T[]) <span class="keyword">new</span> Object[len &lt; <span class="number">2</span> * INITIAL_TMP_STORAGE_LENGTH ? len &gt;&gt;&gt; <span class="number">1</span></div><div class="line">        : INITIAL_TMP_STORAGE_LENGTH];</div><div class="line">    tmp = newArray;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 这里是分配储存run的栈的空间，它不能在运行时扩展。 C语言版本中的栈一直使用固定值85，但这样对一些中小数组来说有些浪费资源。所以，</span></div><div class="line"><span class="comment">     * 这个版本我们使用了相对较小容量的栈。 在MIN_MERGE减小的时候，这些‘魔法数’可能面临数组越界的风险。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> stackLen = (len &lt; <span class="number">120</span> ? <span class="number">5</span> : len &lt; <span class="number">1542</span> ? <span class="number">10</span> : len &lt; <span class="number">119151</span> ? <span class="number">24</span> : <span class="number">40</span>);</div><div class="line">    runBase = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</div><div class="line">    runLen = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</div><div class="line">    sort(a, <span class="number">0</span>, a.length, c);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">      Arrays.sort(a, lo, hi);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    rangeCheck(a.length, lo, hi);</div><div class="line">    <span class="keyword">int</span> nRemaining = hi - lo;</div><div class="line">    <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</div><div class="line">      <span class="keyword">return</span>; <span class="comment">// 长度是0或者1 就不需要排序了。</span></div><div class="line"></div><div class="line">    <span class="comment">// 小于MIN_MERGE长度的数组就不用归并排序了，杀鸡焉用宰牛刀</span></div><div class="line">    <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</div><div class="line">      <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);</div><div class="line">      binarySort(a, lo, hi, lo + initRunLen, c);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * March over the array once, left to right, finding natural runs, extending</span></div><div class="line"><span class="comment">     * short natural runs to minRun elements, and merging runs to maintain stack</span></div><div class="line"><span class="comment">     * invariant.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 下面将进入算法流程的主体,首先理解源码注释中run的含义，可以理解为升序序列的意思。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 从左到右，遍历一边数组。找出自然排好序的序列(natural run)，把短的自然升序序列通过二叉查找排序</span></div><div class="line"><span class="comment">     * 扩展到minRun长度的升序序列。最后合并栈中的所有升序序列，保证规则不变。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    TimSort&lt;T&gt; ts = <span class="keyword">new</span> TimSort&lt;&gt;(a, c); <span class="comment">// 新建TimSort对象，保存栈的状态</span></div><div class="line">    <span class="keyword">int</span> minRun = minRunLength(nRemaining);</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">      <span class="comment">// 跟二叉查找插入排序一样，先找自然升序序列</span></div><div class="line">      <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi, c);</div><div class="line"></div><div class="line">      <span class="comment">// If run is short, extend to min(minRun, nRemaining)</span></div><div class="line">      <span class="comment">// 如果 自然升序的长度不够minRun，就把 min(minRun,nRemaining)长度的范围内的数列排好序</span></div><div class="line">      <span class="keyword">if</span> (runLen &lt; minRun) &#123;</div><div class="line">        <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</div><div class="line">        binarySort(a, lo, lo + force, lo + runLen, c);</div><div class="line">        runLen = force;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// Push run onto pending-run stack, and maybe merge</span></div><div class="line">      <span class="comment">// 把已经排好序的数列压入栈中，检查是不是需要合并</span></div><div class="line">      ts.pushRun(lo, runLen);</div><div class="line">      ts.mergeCollapse();</div><div class="line"></div><div class="line">      <span class="comment">// 把指针后移runLen距离，准备开始下一轮片段的排序</span></div><div class="line">      lo += runLen;</div><div class="line">      <span class="comment">// 剩下待排序的数量相应的减少 runLen</span></div><div class="line">      nRemaining -= runLen;</div><div class="line">    &#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Merge all remaining runs to complete sort</span></div><div class="line">    <span class="keyword">assert</span> lo == hi;</div><div class="line">    ts.mergeForceCollapse();</div><div class="line">    <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 被优化的二分插入排序</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * 使用二分插入排序算法给指定一部分数组排序。这是给小数组排序的最佳方案。最差情况下 它需要 O(n log n) 次比较和 O(n^2)次数据移动。</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * 如果开始的部分数据是有序的那么我们可以利用它们。这个方法默认数组中的位置lo(包括在内)到 start(不包括在内)的范围内是已经排好序的。</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> a</span></div><div class="line"><span class="comment">   *          被排序的数组</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> lo</span></div><div class="line"><span class="comment">   *          待排序范围内的首个元素的位置</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> hi</span></div><div class="line"><span class="comment">   *          待排序范围内最后一个元素的后一个位置</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> start</span></div><div class="line"><span class="comment">   *          待排序范围内的第一个没有排好序的位置，确保 (lo &lt;= start &lt;= hi)</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> c</span></div><div class="line"><span class="comment">   *          本次排序的比较器</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"fallthrough"</span>)</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> start, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> lo &lt;= start &amp;&amp; start &lt;= hi;</div><div class="line">    <span class="comment">// 如果start 从起点开始，做下预处理；也就是原本就是无序的。</span></div><div class="line">    <span class="keyword">if</span> (start == lo)</div><div class="line">      start++;</div><div class="line">    <span class="comment">// 从start位置开始，对后面的所有元素排序</span></div><div class="line">    <span class="keyword">for</span> (; start &lt; hi; start++) &#123;</div><div class="line">      <span class="comment">// pivot 代表正在参与排序的值，</span></div><div class="line">      T pivot = a[start];</div><div class="line"></div><div class="line">      <span class="comment">// Set left (and right) to the index where a[start] (pivot) belongs</span></div><div class="line">      <span class="comment">// 把pivot应当插入的设置的边界设置为left和right</span></div><div class="line">      <span class="keyword">int</span> left = lo;</div><div class="line">      <span class="keyword">int</span> right = start;</div><div class="line">      <span class="keyword">assert</span> left &lt;= right;</div><div class="line"></div><div class="line">      <span class="comment">/*</span></div><div class="line"><span class="comment">       * 保证的逻辑: pivot &gt;= all in [lo, left). pivot &lt; all in [right, start).</span></div><div class="line"><span class="comment">       */</span></div><div class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (c.compare(pivot, a[mid]) &lt; <span class="number">0</span>)</div><div class="line">          right = mid;</div><div class="line">        <span class="keyword">else</span></div><div class="line">          left = mid + <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">assert</span> left == right;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line"><span class="comment">       * 此时，仍然能保证: pivot &gt;= [lo, left) &amp;&amp; pivot &lt; [left,start)</span></div><div class="line"><span class="comment">       * 所以，pivot的值应当在left所在的位置，然后需要把[left,start)范围内的内容整体右移一位</span></div><div class="line"><span class="comment">       * 腾出空间。如果pivot与区间中的某个值相等，left指正会指向重复的值的后一位， 所以这里的排序是稳定的。</span></div><div class="line"><span class="comment">       */</span></div><div class="line">      <span class="keyword">int</span> n = start - left; <span class="comment">// 需要移动的范围的长度</span></div><div class="line"></div><div class="line">      <span class="comment">// switch语句是一条小优化，1-2个元素的移动就不需要System.arraycopy了。</span></div><div class="line">      <span class="comment">// （这代码写的真是简洁，switch原来可以这样用）</span></div><div class="line">      <span class="keyword">switch</span> (n) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        a[left + <span class="number">2</span>] = a[left + <span class="number">1</span>];</div><div class="line">      <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        a[left + <span class="number">1</span>] = a[left];</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        System.arraycopy(a, left, a, left + <span class="number">1</span>, n);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 移动过之后，把pivot的值放到应该插入的位置，就是left的位置了</span></div><div class="line">      a[left] = pivot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 这一段代码是TimSort算法中的一个小优化，它利用了数组中前面一段已有的顺序。</span></div><div class="line"><span class="comment">   * 如果是升序，直接返回统计结果；如果是降序，在返回之前，将这段数列倒置， 以确保这断序列从首个位置到此位置的序列都是升序的。</span></div><div class="line"><span class="comment">   * 返回的结果是这种两种形式的，lo是这段序列的开始位置。</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * A run is the longest ascending sequence with:</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * a[lo] &lt;= a[lo + 1] &lt;= a[lo + 2] &lt;= ...</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * or the longest descending sequence with:</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * a[lo] &gt; a[lo + 1] &gt; a[lo + 2] &gt; ...</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * 为了保证排序的稳定性，这里要使用严格的降序，这样才能保证相等的元素不参与倒置子序列的过程， 保证它们原本的顺序不被打乱。</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> a</span></div><div class="line"><span class="comment">   *          参与排序的数组</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> lo</span></div><div class="line"><span class="comment">   *          run中首个元素的位置</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> hi</span></div><div class="line"><span class="comment">   *          run中最后一个元素的后面一个位置，需要确保lo&lt;hi</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> c</span></div><div class="line"><span class="comment">   *          本次排序的比较器</span></div><div class="line"><span class="comment">   * <span class="doctag">@return</span> 从首个元素开始的最长升序子序列的结尾位置+1 or 严格的降序子序列的结尾位置+1。</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> lo &lt; hi;</div><div class="line">    <span class="keyword">int</span> runHi = lo + <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (runHi == hi)</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 找出最长升序序的子序列，如果降序，倒置之</span></div><div class="line">    <span class="keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="number">0</span>) &#123; <span class="comment">// 前两个元素是降序，就按照降序统计</span></div><div class="line">      <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</div><div class="line">        runHi++;</div><div class="line">      reverseRange(a, lo, runHi);</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 前两个元素是升序，按照升序统计</span></div><div class="line">      <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</div><div class="line">        runHi++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> runHi - lo;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 倒置数组中一段范围的元素</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> a</span></div><div class="line"><span class="comment">   *          指定数组</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> lo</span></div><div class="line"><span class="comment">   *          这段范围的起始位置</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> hi</span></div><div class="line"><span class="comment">   *          这段范围的终点位置的后一个位置</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseRange</span><span class="params">(Object[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    hi--;</div><div class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</div><div class="line">      Object t = a[lo];</div><div class="line">      a[lo++] = a[hi];</div><div class="line">      a[hi--] = t;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 返回参与合并的最小长度，如果自然排序的长度，小于此长度，那么就通过二分查找排序扩展到 此长度。&#123;<span class="doctag">@link</span> #binarySort&#125;.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * 粗略的讲，计算结果是这样的：</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * 如果 n &lt; MIN_MERGE, 直接返回 n。（太小了，不值得做复杂的操作）； 如果 n 正好是2的幂，返回 n / 2； 其它情况下 返回一个数</span></div><div class="line"><span class="comment">   * k，满足 MIN_MERGE/2 &lt;= k &lt;= MIN_MERGE, 这样结果就能保证 n/k 非常接近但小于一个2的幂。</span></div><div class="line"><span class="comment">   * 这个数字实际上是一种空间与时间的优化。</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> n</span></div><div class="line"><span class="comment">   *          参与排序的数组的长度</span></div><div class="line"><span class="comment">   * <span class="doctag">@return</span> 参与归并的最短长度 这段代码写得也很赞</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minRunLength</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> n &gt;= <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> r = <span class="number">0</span>; <span class="comment">// 只要不是 2的幂就会置 1</span></div><div class="line">    <span class="keyword">while</span> (n &gt;= MIN_MERGE) &#123;</div><div class="line">      r |= (n &amp; <span class="number">1</span>);</div><div class="line">      n &gt;&gt;= <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> n + r;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Pushes the specified run onto the pending-run stack. 将指定的升序序列压入等待合并的栈中</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> runBase</span></div><div class="line"><span class="comment">   *          升序序列的首个元素的位置</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> runLen</span></div><div class="line"><span class="comment">   *          升序序列的长度</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushRun</span><span class="params">(<span class="keyword">int</span> runBase, <span class="keyword">int</span> runLen)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.runBase[stackSize] = runBase;</div><div class="line">    <span class="keyword">this</span>.runLen[stackSize] = runLen;</div><div class="line">    stackSize++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 检查栈中待归并的升序序列，如果他们不满足下列条件就把相邻的两个序列合并， 直到他们满足下面的条件</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * 1. runLen[i - 3] &gt; runLen[i - 2] + runLen[i - 1] 2. runLen[i - 2] &gt;</span></div><div class="line"><span class="comment">   * runLen[i - 1]</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * 每次添加新序列到栈中的时候都会执行一次这个操作。所以栈中的需要满足的条件 需要靠调用这个方法来维护。</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * 最差情况下，有点像玩2048。</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeCollapse</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (stackSize &gt; <span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">int</span> n = stackSize - <span class="number">2</span>;</div><div class="line">      <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; runLen[n - <span class="number">1</span>] &lt;= runLen[n] + runLen[n + <span class="number">1</span>]) &#123;</div><div class="line">        <span class="keyword">if</span> (runLen[n - <span class="number">1</span>] &lt; runLen[n + <span class="number">1</span>])</div><div class="line">          n--;</div><div class="line">        mergeAt(n);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (runLen[n] &lt;= runLen[n + <span class="number">1</span>]) &#123;</div><div class="line">        mergeAt(n);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">break</span>; <span class="comment">// Invariant is established</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 合并栈中所有待合并的序列，最后剩下一个序列。这个方法在整次排序中只执行一次</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeForceCollapse</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (stackSize &gt; <span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">int</span> n = stackSize - <span class="number">2</span>;</div><div class="line">      <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; runLen[n - <span class="number">1</span>] &lt; runLen[n + <span class="number">1</span>])</div><div class="line">        n--;</div><div class="line">      mergeAt(n);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 在一个序列中，将一个指定的key，从左往右查找它应当插入的位置；如果序列中存在 与key相同的值(一个或者多个)，那返回这些值中最左边的位置。</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * 推断： 统计概率的原因，随机数字来说，两个待合并的序列的尾假设是差不多大的，从尾开始 做查找找到的概率高一些。仔细算一下，最差情况下，这种查找也是</span></div><div class="line"><span class="comment">   * log(n)，所以这里没有 用简单的二分查找。</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></div><div class="line"><span class="comment">   *          准备插入的key</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> a</span></div><div class="line"><span class="comment">   *          参与排序的数组</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> base</span></div><div class="line"><span class="comment">   *          序列范围的第一个元素的位置</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> len</span></div><div class="line"><span class="comment">   *          整个范围的长度，一定有len &gt; 0</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> hint</span></div><div class="line"><span class="comment">   *          开始查找的位置，有0 &lt;= hint &lt;= len;越接近结果查找越快</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> c</span></div><div class="line"><span class="comment">   *          排序，查找使用的比较器</span></div><div class="line"><span class="comment">   * <span class="doctag">@return</span> 返回一个整数 k, 有 0 &lt;= k &lt;=n, 它满足 a[b + k - 1] &lt; a[b + k] 就是说key应当被放在</span></div><div class="line"><span class="comment">   *         a[base + k], 有 a[base,base+k) &lt; key &amp;&amp; key &lt;=a [base + k, base +</span></div><div class="line"><span class="comment">   *         len)</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">gallopLeft</span><span class="params">(T key, T[] a, <span class="keyword">int</span> base, <span class="keyword">int</span> len, <span class="keyword">int</span> hint,</span></span></div><div class="line"><span class="function"><span class="params">      Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> len &gt; <span class="number">0</span> &amp;&amp; hint &gt;= <span class="number">0</span> &amp;&amp; hint &lt; len;</div><div class="line">    <span class="keyword">int</span> lastOfs = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> ofs = <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (c.compare(key, a[base + hint]) &gt; <span class="number">0</span>) &#123; <span class="comment">// key &gt; a[base+hint]</span></div><div class="line">      <span class="comment">// 遍历右边，直到 a[base+hint+lastOfs] &lt; key &lt;= a[base+hint+ofs]</span></div><div class="line">      <span class="keyword">int</span> maxOfs = len - hint;</div><div class="line">      <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint + ofs]) &gt; <span class="number">0</span>) &#123;</div><div class="line">        lastOfs = ofs;</div><div class="line">        ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>) <span class="comment">// int overflow</span></div><div class="line">          ofs = maxOfs;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (ofs &gt; maxOfs)</div><div class="line">        ofs = maxOfs;</div><div class="line"></div><div class="line">      <span class="comment">// 最终的ofs是这样确定的，满足条件 a[base+hint+lastOfs] &lt; key &lt;= a[base+hint+ofs]</span></div><div class="line">      <span class="comment">// 的一组</span></div><div class="line">      <span class="comment">// ofs: 1 3 7 15 31 63 2^n-1 ... maxOfs</span></div><div class="line">      <span class="comment">// lastOfs: 0 1 3 7 15 31 2^(n-1)-1 &lt; ofs</span></div><div class="line"></div><div class="line">      <span class="comment">// 因为目前的offset是相对hint的，所以做相对变换</span></div><div class="line">      lastOfs += hint;</div><div class="line">      ofs += hint;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// key &lt;= a[base + hint]</span></div><div class="line">      <span class="comment">// 遍历左边，直到[base+hint-ofs] &lt; key &lt;= a[base+hint-lastOfs]</span></div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> maxOfs = hint + <span class="number">1</span>;</div><div class="line">      <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint - ofs]) &lt;= <span class="number">0</span>) &#123;</div><div class="line">        lastOfs = ofs;</div><div class="line">        ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>) <span class="comment">// int overflow</span></div><div class="line">          ofs = maxOfs;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (ofs &gt; maxOfs)</div><div class="line">        ofs = maxOfs;</div><div class="line">      <span class="comment">// 确定ofs的过程与上面相同</span></div><div class="line">      <span class="comment">// ofs: 1 3 7 15 31 63 2^n-1 ... maxOfs</span></div><div class="line">      <span class="comment">// lastOfs: 0 1 3 7 15 31 2^(n-1)-1 &lt; ofs</span></div><div class="line"></div><div class="line">      <span class="comment">// Make offsets relative to base</span></div><div class="line">      <span class="keyword">int</span> tmp = lastOfs;</div><div class="line">      lastOfs = hint - ofs;</div><div class="line">      ofs = hint - tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">assert</span> -<span class="number">1</span> &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 现在的情况是 a[base+lastOfs] &lt; key &lt;= a[base+ofs], 所以，key应当在lastOfs的</span></div><div class="line"><span class="comment">     * 右边，又不超过ofs。在base+lastOfs-1到 base+ofs范围内做一次二叉查找。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    lastOfs++;</div><div class="line">    <span class="keyword">while</span> (lastOfs &lt; ofs) &#123;</div><div class="line">      <span class="keyword">int</span> m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; <span class="number">1</span>);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (c.compare(key, a[base + m]) &gt; <span class="number">0</span>)</div><div class="line">        lastOfs = m + <span class="number">1</span>; <span class="comment">// a[base + m] &lt; key</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">        ofs = m; <span class="comment">// key &lt;= a[base + m]</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">assert</span> lastOfs == ofs; <span class="comment">// so a[base + ofs - 1] &lt; key &lt;= a[base + ofs]</span></div><div class="line">    <span class="keyword">return</span> ofs;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 与gallopLeft相似，不同的是如果发现key的值与某些元素相等，那返回这些值最后一个元素的位置的 后一个位置</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></div><div class="line"><span class="comment">   *          需要查找待插入位置的那个值</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> a</span></div><div class="line"><span class="comment">   *          待排序的数组</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> base</span></div><div class="line"><span class="comment">   *          被查找的序列中第一个元素的位置</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> len</span></div><div class="line"><span class="comment">   *          被查找的序列的长度</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> hint</span></div><div class="line"><span class="comment">   *          开始查找的位置，0 &lt;= hint &lt; len.它越接近结果所在位置，查找越快。</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> c</span></div><div class="line"><span class="comment">   *          本次排序的比较器</span></div><div class="line"><span class="comment">   * <span class="doctag">@return</span> 一个整数 k, 满足0 &lt;= k &lt;= n 并且 a[b + k - 1] &lt;= key &lt; a[b + k]</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">gallopRight</span><span class="params">(T key, T[] a, <span class="keyword">int</span> base, <span class="keyword">int</span> len, <span class="keyword">int</span> hint,</span></span></div><div class="line"><span class="function"><span class="params">      Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> len &gt; <span class="number">0</span> &amp;&amp; hint &gt;= <span class="number">0</span> &amp;&amp; hint &lt; len;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ofs = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> lastOfs = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (c.compare(key, a[base + hint]) &lt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// Gallop left until a[b+hint - ofs] &lt;= key &lt; a[b+hint - lastOfs]</span></div><div class="line">      <span class="keyword">int</span> maxOfs = hint + <span class="number">1</span>;</div><div class="line">      <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint - ofs]) &lt; <span class="number">0</span>) &#123;</div><div class="line">        lastOfs = ofs;</div><div class="line">        ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>) <span class="comment">// int overflow</span></div><div class="line">          ofs = maxOfs;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (ofs &gt; maxOfs)</div><div class="line">        ofs = maxOfs;</div><div class="line"></div><div class="line">      <span class="comment">// Make offsets relative to b</span></div><div class="line">      <span class="keyword">int</span> tmp = lastOfs;</div><div class="line">      lastOfs = hint - ofs;</div><div class="line">      ofs = hint - tmp;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// a[b + hint] &lt;= key</span></div><div class="line">      <span class="comment">// Gallop right until a[b+hint + lastOfs] &lt;= key &lt; a[b+hint + ofs]</span></div><div class="line">      <span class="keyword">int</span> maxOfs = len - hint;</div><div class="line">      <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint + ofs]) &gt;= <span class="number">0</span>) &#123;</div><div class="line">        lastOfs = ofs;</div><div class="line">        ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>) <span class="comment">// int overflow</span></div><div class="line">          ofs = maxOfs;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (ofs &gt; maxOfs)</div><div class="line">        ofs = maxOfs;</div><div class="line"></div><div class="line">      <span class="comment">// Make offsets relative to b</span></div><div class="line">      lastOfs += hint;</div><div class="line">      ofs += hint;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">assert</span> -<span class="number">1</span> &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Now a[b + lastOfs] &lt;= key &lt; a[b + ofs], so key belongs somewhere to the</span></div><div class="line"><span class="comment">     * right of lastOfs but no farther right than ofs. Do a binary search, with</span></div><div class="line"><span class="comment">     * invariant a[b + lastOfs - 1] &lt;= key &lt; a[b + ofs].</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    lastOfs++;</div><div class="line">    <span class="keyword">while</span> (lastOfs &lt; ofs) &#123;</div><div class="line">      <span class="keyword">int</span> m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; <span class="number">1</span>);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (c.compare(key, a[base + m]) &lt; <span class="number">0</span>)</div><div class="line">        ofs = m; <span class="comment">// key &lt; a[b + m]</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">        lastOfs = m + <span class="number">1</span>; <span class="comment">// a[b + m] &lt;= key</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">assert</span> lastOfs == ofs; <span class="comment">// so a[b + ofs - 1] &lt;= key &lt; a[b + ofs]</span></div><div class="line">    <span class="keyword">return</span> ofs;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 合并在栈中位于i和i+1的两个相邻的升序序列。 i必须为从栈顶数，第二和第三个元素。 换句话说i == stackSize - 2 || i ==</span></div><div class="line"><span class="comment">   * stackSize - 3</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> i</span></div><div class="line"><span class="comment">   *          待合并的第一个序列所在的位置</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="comment">// 校验</span></div><div class="line">    <span class="keyword">assert</span> stackSize &gt;= <span class="number">2</span>;</div><div class="line">    <span class="keyword">assert</span> i &gt;= <span class="number">0</span>;</div><div class="line">    <span class="keyword">assert</span> i == stackSize - <span class="number">2</span> || i == stackSize - <span class="number">3</span>;</div><div class="line">    <span class="comment">// 内部初始化</span></div><div class="line">    <span class="keyword">int</span> base1 = runBase[i];</div><div class="line">    <span class="keyword">int</span> len1 = runLen[i];</div><div class="line">    <span class="keyword">int</span> base2 = runBase[i + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> len2 = runLen[i + <span class="number">1</span>];</div><div class="line">    <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</div><div class="line">    <span class="keyword">assert</span> base1 + len1 == base2;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 记录合并后的序列的长度；如果i == stackSize - 3 就把最后一个序列的信息</span></div><div class="line"><span class="comment">     * 往前移一位，因为本次合并不关它的事。i+1对应的序列被合并到i序列中了，所以 i+1 数列可以消失了</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    runLen[i] = len1 + len2;</div><div class="line">    <span class="keyword">if</span> (i == stackSize - <span class="number">3</span>) &#123;</div><div class="line">      runBase[i + <span class="number">1</span>] = runBase[i + <span class="number">2</span>];</div><div class="line">      runLen[i + <span class="number">1</span>] = runLen[i + <span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// i+1消失了，所以长度也减下来了</span></div><div class="line">    stackSize--;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 找出第二个序列的首个元素可以插入到第一个序列的什么位置，因为在此位置之前的序列已经就位了。 它们可以被忽略，不参加归并。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> k = gallopRight(a[base2], a, base1, len1, <span class="number">0</span>, c);</div><div class="line">    <span class="keyword">assert</span> k &gt;= <span class="number">0</span>;</div><div class="line">    <span class="comment">// 因为要忽略前半部分元素，所以起点和长度相应的变化</span></div><div class="line">    base1 += k;</div><div class="line">    len1 -= k;</div><div class="line">    <span class="comment">// 如果序列2 的首个元素要插入到序列1的后面，那就直接结束了,</span></div><div class="line">    <span class="comment">// ！！！ 因为序列2在数组中的位置本来就在序列1后面,也就是整个范围本来就是有序的！！！</span></div><div class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 跟上面相似，看序列1的最后一个元素(a[base1+len1-1])可以插入到序列2的什么位置（相对第二个序列起点的位置，非在数组中的位置），</span></div><div class="line"><span class="comment">     * 这个位置后面的元素也是不需要参与归并的。所以len2直接设置到这里，后面的元素直接忽略。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    len2 = gallopLeft(a[base1 + len1 - <span class="number">1</span>], a, base2, len2, len2 - <span class="number">1</span>, c);</div><div class="line">    <span class="keyword">assert</span> len2 &gt;= <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (len2 == <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 合并剩下的两个有序序列，并且这里为了节省空间，临时数组选用 min(len1,len2)的长度</span></div><div class="line">    <span class="comment">// 优化的很细呢</span></div><div class="line">    <span class="keyword">if</span> (len1 &lt;= len2)</div><div class="line">      mergeLo(base1, len1, base2, len2);</div><div class="line">    <span class="keyword">else</span></div><div class="line">      mergeHi(base1, len1, base2, len2);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 使用固定空间合并两个相邻的有序序列，保持数组的稳定性。 使用本方法之前保证第一个序列的首个元素大于第二个序列的首个元素；第一个序列的末尾元素</span></div><div class="line"><span class="comment">   * 大于第二个序列的所有元素</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * 为了性能，这个方法在len1 &lt;= len2的时候调用；它的姐妹方法mergeHi应该在len1 &gt;= len2</span></div><div class="line"><span class="comment">   * 的时候调用。len1==len2的时候随便调用哪个都可以</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> base1</span></div><div class="line"><span class="comment">   *          index of first element in first run to be merged</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> len1</span></div><div class="line"><span class="comment">   *          length of first run to be merged (must be &gt; 0)</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> base2</span></div><div class="line"><span class="comment">   *          index of first element in second run to be merged (must be aBase +</span></div><div class="line"><span class="comment">   *          aLen)</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> len2</span></div><div class="line"><span class="comment">   *          length of second run to be merged (must be &gt; 0)</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeLo</span><span class="params">(<span class="keyword">int</span> base1, <span class="keyword">int</span> len1, <span class="keyword">int</span> base2, <span class="keyword">int</span> len2)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span> &amp;&amp; base1 + len1 == base2;</div><div class="line"></div><div class="line">    <span class="comment">// 将第一个序列放到临时数组中</span></div><div class="line">    T[] a = <span class="keyword">this</span>.a; <span class="comment">// For performance</span></div><div class="line">    T[] tmp = ensureCapacity(len1);</div><div class="line">    System.arraycopy(a, base1, tmp, <span class="number">0</span>, len1);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> cursor1 = <span class="number">0</span>; <span class="comment">// 临时数组指针</span></div><div class="line">    <span class="keyword">int</span> cursor2 = base2; <span class="comment">// 序列2的指针，参与归并的另一个序列</span></div><div class="line">    <span class="keyword">int</span> dest = base1; <span class="comment">// 保存结果的指针</span></div><div class="line"></div><div class="line">    <span class="comment">// 这里先把第二个序列的首个元素，移动到结果序列中的位置，然后处理那些不需要归并的情况</span></div><div class="line">    a[dest++] = a[cursor2++];</div><div class="line"></div><div class="line">    <span class="comment">// 序列2只有一个元素的情况，把它移动到指定位置之后，剩下的临时数组</span></div><div class="line">    <span class="comment">// 中的所有序列1的元素全部copy到后面</span></div><div class="line">    <span class="keyword">if</span> (--len2 == <span class="number">0</span>) &#123;</div><div class="line">      System.arraycopy(tmp, cursor1, a, dest, len1);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 序列1只有一个元素的情况，把它移动到最后一个位置，为了不覆盖，先把序列2中的元素</span></div><div class="line">    <span class="comment">// 全部移走。这个是因为序列1中的最后一个元素比序列2中的所有元素都大，这是该方法执行的条件</span></div><div class="line">    <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123;</div><div class="line">      System.arraycopy(a, cursor2, a, dest, len2);</div><div class="line">      a[dest + len2] = tmp[cursor1]; <span class="comment">// Last elt of run 1 to end of merge</span></div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Comparator&lt;? <span class="keyword">super</span> T&gt; c = <span class="keyword">this</span>.c; <span class="comment">// 本次排序的比较器</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> minGallop = <span class="keyword">this</span>.minGallop; <span class="comment">// " " " " "</span></div><div class="line"></div><div class="line">    <span class="comment">// 不了解break标签的同学要补补Java基本功了</span></div><div class="line">    outer: <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="comment">/*</span></div><div class="line"><span class="comment">       * 这里加了两个值来记录一个序列连续比另外一个大的次数，根据此信息，可以做出一些 优化</span></div><div class="line"><span class="comment">       */</span></div><div class="line">      <span class="keyword">int</span> count1 = <span class="number">0</span>; <span class="comment">// 序列1 连续 比序列2大多少次</span></div><div class="line">      <span class="keyword">int</span> count2 = <span class="number">0</span>; <span class="comment">// 序列2 连续 比序列1大多少次</span></div><div class="line"></div><div class="line">      <span class="comment">/*</span></div><div class="line"><span class="comment">       * 这里是直接的归并算法的合并的部分，这里会统计count1合count2, 如果其中一个大于一个阈值，就会跳出循环</span></div><div class="line"><span class="comment">       */</span></div><div class="line">      <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">1</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (c.compare(a[cursor2], tmp[cursor1]) &lt; <span class="number">0</span>) &#123;</div><div class="line">          a[dest++] = a[cursor2++];</div><div class="line">          count2++;</div><div class="line">          count1 = <span class="number">0</span>;</div><div class="line"></div><div class="line">          <span class="comment">// 序列2没有元素了就跳出整次合并</span></div><div class="line">          <span class="keyword">if</span> (--len2 == <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span> outer;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          a[dest++] = tmp[cursor1++];</div><div class="line">          count1++;</div><div class="line">          count2 = <span class="number">0</span>;</div><div class="line">          <span class="comment">// 如果序列1只剩下最后一个元素了就可以跳出循环</span></div><div class="line">          <span class="keyword">if</span> (--len1 == <span class="number">1</span>)</div><div class="line">            <span class="keyword">break</span> outer;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * 这个判断相当于 count1 &lt; minGallop &amp;&amp; count2 &lt;minGallop 因为count1和count2总有一个为0</span></div><div class="line"><span class="comment">         */</span></div><div class="line">      &#125; <span class="keyword">while</span> ((count1 | count2) &lt; minGallop);</div><div class="line"></div><div class="line">      <span class="comment">/*</span></div><div class="line"><span class="comment">       * 执行到这里的话，一个序列会连续的的比另一个序列大，那么这种连续性可能持续的</span></div><div class="line"><span class="comment">       * 更长。那么我们就按照这个逻辑试一试。直到这种连续性被打破。根据找到的长度， 直接连续的copy就可以了，这样可以提高copy的效率。</span></div><div class="line"><span class="comment">       */</span></div><div class="line">      <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">1</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</div><div class="line">        <span class="comment">// gallopRight就是之前用过的那个方法</span></div><div class="line">        count1 = gallopRight(a[cursor2], tmp, cursor1, len1, <span class="number">0</span>, c);</div><div class="line">        <span class="keyword">if</span> (count1 != <span class="number">0</span>) &#123;</div><div class="line">          System.arraycopy(tmp, cursor1, a, dest, count1);</div><div class="line">          dest += count1;</div><div class="line">          cursor1 += count1;</div><div class="line">          len1 -= count1;</div><div class="line">          <span class="keyword">if</span> (len1 &lt;= <span class="number">1</span>) <span class="comment">// 结尾处理退化的序列</span></div><div class="line">            <span class="keyword">break</span> outer;</div><div class="line">        &#125;</div><div class="line">        a[dest++] = a[cursor2++];</div><div class="line">        <span class="keyword">if</span> (--len2 == <span class="number">0</span>) <span class="comment">// 结尾处理退化的序列</span></div><div class="line">          <span class="keyword">break</span> outer;</div><div class="line"></div><div class="line">        count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, <span class="number">0</span>, c);</div><div class="line">        <span class="keyword">if</span> (count2 != <span class="number">0</span>) &#123;</div><div class="line">          System.arraycopy(a, cursor2, a, dest, count2);</div><div class="line">          dest += count2;</div><div class="line">          cursor2 += count2;</div><div class="line">          len2 -= count2;</div><div class="line">          <span class="keyword">if</span> (len2 == <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span> outer;</div><div class="line">        &#125;</div><div class="line">        a[dest++] = tmp[cursor1++];</div><div class="line">        <span class="keyword">if</span> (--len1 == <span class="number">1</span>)</div><div class="line">          <span class="keyword">break</span> outer;</div><div class="line">        <span class="comment">// 这里对连续性比另外一个大的阈值减少，这样更容易触发这段操作，</span></div><div class="line">        <span class="comment">// 应该是因为前面的数据表现好，后面的数据类似的可能性更高？</span></div><div class="line">        minGallop--;</div><div class="line">      &#125; <span class="keyword">while</span> (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP); <span class="comment">// 如果连续性还是很大的话，继续这样处理s</span></div><div class="line"></div><div class="line">      <span class="keyword">if</span> (minGallop &lt; <span class="number">0</span>)</div><div class="line">        minGallop = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="comment">// 同样，这里如果跳出了那段循环，就证明数据的顺序程度不好，应当增加阈值，避免浪费资源</span></div><div class="line">      minGallop += <span class="number">2</span>;</div><div class="line">    &#125; <span class="comment">// outer 结束</span></div><div class="line"></div><div class="line">    <span class="keyword">this</span>.minGallop = minGallop &lt; <span class="number">1</span> ? <span class="number">1</span> : minGallop; <span class="comment">// Write back to field</span></div><div class="line"></div><div class="line">    <span class="comment">// 这里处理收尾工作</span></div><div class="line">    <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">assert</span> len2 &gt; <span class="number">0</span>;</div><div class="line">      System.arraycopy(a, cursor2, a, dest, len2);</div><div class="line">      a[dest + len2] = tmp[cursor1]; <span class="comment">// Last elt of run 1 to end of merge</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// 因为序列1中的最后一个值，比序列2中的所有值都大，所以，不可能序列1空了，序列2还有元素</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Comparison method violates its general contract!"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">assert</span> len2 == <span class="number">0</span>;</div><div class="line">      <span class="keyword">assert</span> len1 &gt; <span class="number">1</span>;</div><div class="line">      System.arraycopy(tmp, cursor1, a, dest, len1);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Like mergeLo, except that this method should be called only if len1 &gt;=</span></div><div class="line"><span class="comment">   * len2; mergeLo should be called if len1 &lt;= len2. (Either method may be</span></div><div class="line"><span class="comment">   * called if len1 == len2.)</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> base1</span></div><div class="line"><span class="comment">   *          index of first element in first run to be merged</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> len1</span></div><div class="line"><span class="comment">   *          length of first run to be merged (must be &gt; 0)</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> base2</span></div><div class="line"><span class="comment">   *          index of first element in second run to be merged (must be aBase +</span></div><div class="line"><span class="comment">   *          aLen)</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> len2</span></div><div class="line"><span class="comment">   *          length of second run to be merged (must be &gt; 0)</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeHi</span><span class="params">(<span class="keyword">int</span> base1, <span class="keyword">int</span> len1, <span class="keyword">int</span> base2, <span class="keyword">int</span> len2)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span> &amp;&amp; base1 + len1 == base2;</div><div class="line"></div><div class="line">    <span class="comment">// Copy second run into temp array</span></div><div class="line">    T[] a = <span class="keyword">this</span>.a; <span class="comment">// For performance</span></div><div class="line">    T[] tmp = ensureCapacity(len2);</div><div class="line">    System.arraycopy(a, base2, tmp, <span class="number">0</span>, len2);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> cursor1 = base1 + len1 - <span class="number">1</span>; <span class="comment">// Indexes into a</span></div><div class="line">    <span class="keyword">int</span> cursor2 = len2 - <span class="number">1</span>; <span class="comment">// Indexes into tmp array</span></div><div class="line">    <span class="keyword">int</span> dest = base2 + len2 - <span class="number">1</span>; <span class="comment">// Indexes into a</span></div><div class="line"></div><div class="line">    <span class="comment">// Move last element of first run and deal with degenerate cases</span></div><div class="line">    a[dest--] = a[cursor1--];</div><div class="line">    <span class="keyword">if</span> (--len1 == <span class="number">0</span>) &#123;</div><div class="line">      System.arraycopy(tmp, <span class="number">0</span>, a, dest - (len2 - <span class="number">1</span>), len2);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (len2 == <span class="number">1</span>) &#123;</div><div class="line">      dest -= len1;</div><div class="line">      cursor1 -= len1;</div><div class="line">      System.arraycopy(a, cursor1 + <span class="number">1</span>, a, dest + <span class="number">1</span>, len1);</div><div class="line">      a[dest] = tmp[cursor2];</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Comparator&lt;? <span class="keyword">super</span> T&gt; c = <span class="keyword">this</span>.c; <span class="comment">// Use local variable for performance</span></div><div class="line">    <span class="keyword">int</span> minGallop = <span class="keyword">this</span>.minGallop; <span class="comment">// " " " " "</span></div><div class="line">    outer: <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="keyword">int</span> count1 = <span class="number">0</span>; <span class="comment">// Number of times in a row that first run won</span></div><div class="line">      <span class="keyword">int</span> count2 = <span class="number">0</span>; <span class="comment">// Number of times in a row that second run won</span></div><div class="line"></div><div class="line">      <span class="comment">/*</span></div><div class="line"><span class="comment">       * Do the straightforward thing until (if ever) one run appears to win</span></div><div class="line"><span class="comment">       * consistently.</span></div><div class="line"><span class="comment">       */</span></div><div class="line">      <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (c.compare(tmp[cursor2], a[cursor1]) &lt; <span class="number">0</span>) &#123;</div><div class="line">          a[dest--] = a[cursor1--];</div><div class="line">          count1++;</div><div class="line">          count2 = <span class="number">0</span>;</div><div class="line">          <span class="keyword">if</span> (--len1 == <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span> outer;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          a[dest--] = tmp[cursor2--];</div><div class="line">          count2++;</div><div class="line">          count1 = <span class="number">0</span>;</div><div class="line">          <span class="keyword">if</span> (--len2 == <span class="number">1</span>)</div><div class="line">            <span class="keyword">break</span> outer;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">while</span> ((count1 | count2) &lt; minGallop);</div><div class="line"></div><div class="line">      <span class="comment">/*</span></div><div class="line"><span class="comment">       * One run is winning so consistently that galloping may be a huge win. So</span></div><div class="line"><span class="comment">       * try that, and continue galloping until (if ever) neither run appears to</span></div><div class="line"><span class="comment">       * be winning consistently anymore.</span></div><div class="line"><span class="comment">       */</span></div><div class="line">      <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">1</span>;</div><div class="line">        count1 = len1 - gallopRight(tmp[cursor2], a, base1, len1, len1 - <span class="number">1</span>, c);</div><div class="line">        <span class="keyword">if</span> (count1 != <span class="number">0</span>) &#123;</div><div class="line">          dest -= count1;</div><div class="line">          cursor1 -= count1;</div><div class="line">          len1 -= count1;</div><div class="line">          System.arraycopy(a, cursor1 + <span class="number">1</span>, a, dest + <span class="number">1</span>, count1);</div><div class="line">          <span class="keyword">if</span> (len1 == <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span> outer;</div><div class="line">        &#125;</div><div class="line">        a[dest--] = tmp[cursor2--];</div><div class="line">        <span class="keyword">if</span> (--len2 == <span class="number">1</span>)</div><div class="line">          <span class="keyword">break</span> outer;</div><div class="line"></div><div class="line">        count2 = len2 - gallopLeft(a[cursor1], tmp, <span class="number">0</span>, len2, len2 - <span class="number">1</span>, c);</div><div class="line">        <span class="keyword">if</span> (count2 != <span class="number">0</span>) &#123;</div><div class="line">          dest -= count2;</div><div class="line">          cursor2 -= count2;</div><div class="line">          len2 -= count2;</div><div class="line">          System.arraycopy(tmp, cursor2 + <span class="number">1</span>, a, dest + <span class="number">1</span>, count2);</div><div class="line">          <span class="keyword">if</span> (len2 &lt;= <span class="number">1</span>) <span class="comment">// len2 == 1 || len2 == 0</span></div><div class="line">            <span class="keyword">break</span> outer;</div><div class="line">        &#125;</div><div class="line">        a[dest--] = a[cursor1--];</div><div class="line">        <span class="keyword">if</span> (--len1 == <span class="number">0</span>)</div><div class="line">          <span class="keyword">break</span> outer;</div><div class="line">        minGallop--;</div><div class="line">      &#125; <span class="keyword">while</span> (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</div><div class="line">      <span class="keyword">if</span> (minGallop &lt; <span class="number">0</span>)</div><div class="line">        minGallop = <span class="number">0</span>;</div><div class="line">      minGallop += <span class="number">2</span>; <span class="comment">// Penalize for leaving gallop mode</span></div><div class="line">    &#125; <span class="comment">// End of "outer" loop</span></div><div class="line">    <span class="keyword">this</span>.minGallop = minGallop &lt; <span class="number">1</span> ? <span class="number">1</span> : minGallop; <span class="comment">// Write back to field</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (len2 == <span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">assert</span> len1 &gt; <span class="number">0</span>;</div><div class="line">      dest -= len1;</div><div class="line">      cursor1 -= len1;</div><div class="line">      System.arraycopy(a, cursor1 + <span class="number">1</span>, a, dest + <span class="number">1</span>, len1);</div><div class="line">      a[dest] = tmp[cursor2]; <span class="comment">// Move first elt of run2 to front of merge</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Comparison method violates its general contract!"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">assert</span> len1 == <span class="number">0</span>;</div><div class="line">      <span class="keyword">assert</span> len2 &gt; <span class="number">0</span>;</div><div class="line">      System.arraycopy(tmp, <span class="number">0</span>, a, dest - (len2 - <span class="number">1</span>), len2);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 保证临时数组的大小能够容纳所有的临时元素，在需要的时候要扩展临时数组的大小。 数组的大小程指数增长，来保证线性的复杂度。</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * 一次申请步长太小，申请的次数必然会增多，浪费时间；一次申请的空间足够大，必然会 浪费空间。正常情况下，归并排序的临时空间每次大的合并都会 * 2，</span></div><div class="line"><span class="comment">   * 最大长度不会超过数组长度的1/2。 这个长度于2 有着紧密的联系。</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> minCapacity</span></div><div class="line"><span class="comment">   *          临时数组需要的最小空间</span></div><div class="line"><span class="comment">   * <span class="doctag">@return</span> tmp 临时数组</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> T[] ensureCapacity(<span class="keyword">int</span> minCapacity) &#123;</div><div class="line">    <span class="comment">// 如果临时数组长度不够，那需要重新计算临时数组长度；</span></div><div class="line">    <span class="comment">// 如果长度够，直接返回当前临时数组</span></div><div class="line">    <span class="keyword">if</span> (tmp.length &lt; minCapacity) &#123;</div><div class="line">      <span class="comment">// 这里是计算最小的大于minCapacity的2的幂。方法不常见，这里分析一下。</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// 假设有无符号整型 k,它的字节码如下：</span></div><div class="line">      <span class="comment">// 00000000 10000000 00000000 00000000 k</span></div><div class="line">      <span class="comment">// 00000000 11000000 00000000 00000000 k |= k &gt;&gt; 1;</span></div><div class="line">      <span class="comment">// 00000000 11110000 00000000 00000000 k |= k &gt;&gt; 2;</span></div><div class="line">      <span class="comment">// 00000000 11111111 00000000 00000000 k |= k &gt;&gt; 4;</span></div><div class="line">      <span class="comment">// 00000000 11111111 11111111 00000000 k |= k &gt;&gt; 8;</span></div><div class="line">      <span class="comment">// 00000000 11111111 11111111 11111111 k |= k &gt;&gt; 16</span></div><div class="line">      <span class="comment">// 上面的移位事实上只跟最高位有关系，移位的结果是最高位往后的bit全部变成了1</span></div><div class="line">      <span class="comment">// 最后 k++ 的结果 就是刚好是比 minCapacity 大的2的幂</span></div><div class="line">      <span class="comment">// 写的真是6</span></div><div class="line">      <span class="keyword">int</span> newSize = minCapacity;</div><div class="line">      newSize |= newSize &gt;&gt; <span class="number">1</span>;</div><div class="line">      newSize |= newSize &gt;&gt; <span class="number">2</span>;</div><div class="line">      newSize |= newSize &gt;&gt; <span class="number">4</span>;</div><div class="line">      newSize |= newSize &gt;&gt; <span class="number">8</span>;</div><div class="line">      newSize |= newSize &gt;&gt; <span class="number">16</span>;</div><div class="line">      newSize++;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (newSize &lt; <span class="number">0</span>) <span class="comment">// Not bloody likely! 估计作者在这里遇到bug了</span></div><div class="line">        newSize = minCapacity;</div><div class="line">      <span class="keyword">else</span></div><div class="line">        newSize = Math.min(newSize, a.length &gt;&gt;&gt; <span class="number">1</span>);</div><div class="line"></div><div class="line">      <span class="meta">@SuppressWarnings</span>(&#123;</div><div class="line">          <span class="string">"unchecked"</span>, <span class="string">"UnnecessaryLocalVariable"</span> &#125;)</div><div class="line">      T[] newArray = (T[]) <span class="keyword">new</span> Object[newSize];</div><div class="line">      tmp = newArray;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tmp;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 检查范围fromIndex到toIndex是否在数组内，如果不是抛异常</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> arrayLen</span></div><div class="line"><span class="comment">   *          整个数组的长度</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> fromIndex</span></div><div class="line"><span class="comment">   *          该范围的起点</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> toIndex</span></div><div class="line"><span class="comment">   *          该范围的终点</span></div><div class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException</span></div><div class="line"><span class="comment">   *           if fromIndex &gt; toIndex</span></div><div class="line"><span class="comment">   * <span class="doctag">@throws</span> ArrayIndexOutOfBoundsException</span></div><div class="line"><span class="comment">   *           if fromIndex &lt; 0 or toIndex &gt; arrayLen</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> arrayLen, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (fromIndex &gt; toIndex)</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"fromIndex("</span> + fromIndex + <span class="string">") &gt; toIndex("</span> + toIndex + <span class="string">")"</span>);</div><div class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(fromIndex);</div><div class="line">    <span class="keyword">if</span> (toIndex &gt; arrayLen)</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(toIndex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://bindog.github.io/blog/2015/03/30/use-formal-method-to-find-the-bug-in-timsort-and-lunar-rover/" target="_blank" rel="external">形式化方法的逆袭——如何找出Timsort算法和玉兔月球车中的Bug？</a><br><a href="http://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="external">Timsort原理介绍</a><br><a href="http://winters1224.blog.51cto.com/3021203/1914094" target="_blank" rel="external">TimSort排序算法及一个问题分析</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>请我喝杯水（°Д°）Ъ</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="http://7xjzgw.com1.z0.glb.clouddn.com/TIM%E5%9B%BE%E7%89%8720170930194516.png" alt="DOGDONG 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="http://7xjzgw.com1.z0.glb.clouddn.com/TIM%E5%9B%BE%E7%89%8720170930194509.jpg" alt="DOGDONG 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
            <a href="/tags/排序/" rel="tag"># 排序</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/27/c++-Numeric-summation/" rel="next" title="数列求和">
                <i class="fa fa-chevron-left"></i> 数列求和
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/07/1710summary/" rel="prev" title="17年10月总结">
                17年10月总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="http://7xjzgw.com1.z0.glb.clouddn.com/TIM%E5%9B%BE%E7%89%8720170930152824.png"
              alt="DOGDONG" />
          
            <p class="site-author-name" itemprop="name">DOGDONG</p>
            <p class="site-description motion-element" itemprop="description">Remembering that you will die, that everything ends, and that happy comes not in denying this but in living with it.</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ischenrui" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://user.qzone.qq.com/593318783" target="_blank" title="QQ空间">
                  
                    <i class="fa fa-fw fa-globe"></i>QQ空间</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Timsort简介"><span class="nav-text">Timsort简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Timsort原理"><span class="nav-text">Timsort原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Step1-分区、入栈、合并"><span class="nav-text">Step1.分区、入栈、合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Step2-合并优化"><span class="nav-text">Step2.合并优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Timsort性能分析"><span class="nav-text">Timsort性能分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#存在的BUG"><span class="nav-text">存在的BUG</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java源码-注释"><span class="nav-text">Java源码+注释</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DOGDONG</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>





<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共19.2k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
